# 指针

---

# 前面都是一些非常无聊的东西 大佬们可以先睡觉

---

# 先来看一些废话吧

---

## 定义
>在计算机科学中，指针（英语：Pointer），是编程语言中的一类数据类型及其对象或变量，用来表示或存储一个存储器地址，这个地址的值直接指向（points to）存在该地址的对象的值。   
指针引用（reference）了存储器中一个地址。通过被称为指针解引用（dereferencing）的动作，可以取出在那个地址中存储的值。保存在指针指向的地址中的值，可能代表另一个变量、结构、对象或函数。但是从从指针值是无法得知它所引用的存储器中存储了什么数据类型的信息。可以打个比方，假设将电脑存储器当成一本书，一张内容记录了某个页码加上行号的便利贴，可以被当成是一个指向特定页面的指针；根据便利粘贴面的页码与行号，翻到那个页面，把那个页面的那一行文字读出来，就相当于是对这个指针进行解引用的动作。可做一类比以增强对指针的理解：整形（integral）也是一类数据类型及其对象或变量，可定义具体的数据类型如短整形（short）、长整形（long）、超长整形（long long）、无符号整形（unsigned）等等；也可以用于称呼整形值、整形对象、整形变量等。又如，一个浮点指针（float *），可称作指向了一个浮点类型的对象。

注:以上废话来自wiki

---

# 所以指针是什么？

---

## 所以指针是什么？
保存变量地址的变量

---

## 指针类型
c语言中你能想到的基础类型,都有其对应的指针类型   
例如:   
1. `char` 型指针 `char*`   
2. `int` 型指针 `int*`   
3. `struct struct_name` 型指针 `(struct struct_name)*`   
4. 指向数组的指针(具体怎么声明后面再讲)   
5. `int*` 型指针 `int**`   
6. 黑科技 `void*`   
7. 黑科技 `函数指针`   
8. 太多了不列了   

---

## 语法
* 最简单的语法  

例:

    !C
    int a, *b = &a; //&a表示取出变量a的地址
    scanf("%p", &a); 
    printf("%p", *b); //*b表示取得该指针指向区域的数据
    printf("%d", (int)b); //(int)b 表示把b强制转换为(int)型 ()

---

## 一点干货(怕是无法满足大佬们)
* 除了long int float char之间的那几个转换，剩下的其实就是欺骗编译器
* 数组变量取地址后类型发生改变但是数值不变  
## 

    !C
    int a[100]
    printf("%d\n", (int)a - (int)&a);

上面那玩意的输出结果是0  
个人猜测是编译器做了特殊处理或者取地址符对数组的优待  

* 数组类型是无法被强制转换而成的，如果你(int[5])a，编译器会直接报错

* 一个有趣的代码，各位可以自己手打试试
##
    !C
    long long tmp = 2851469429137774;
    printf("%s", (char*)&tmp); 

---

## 语法
* 最正常的也是最简单指针声明  

例:  

    !C
    char *a, *b; //每个变量前必须加*
    void *c;
    struct name *d;

* 数组指针声明(这个其实我也不会，现学的)  

例:

    !C
    int (*p)[5], a[5]; //声名了一个类型为 大小为5的int型指针 p(请原谅我的表达)
    p = &a;

---

## 语法
* 指针的指针  

例:

    !C
    int **p; //声明了一个int*型的指针
    int *******************************s; //这玩意是可以编译通过的

* 函数的指针(黑科技！)  
C语言可以通过这玩意实现面向对象  
这玩意我用的也不是很熟练，具体怕是需要请教俸爷  
程序写在下一页   
---

## 语法
例:

    !C
    # include <stdio.h>
    int max(int a, int b)
    {
        if (a > b)
            return a;
        else
            return b;
    }
    int main()
    {
        int (*my_max)(int, int);
        my_max = max;
        printf("%d\n", my_max(1,100));
    }

这不过是函数指针的冰山一角，有许多函数需要以函数为参数，从而完成更加自由的任务，如qsort等

---

## 指针的应用
* 简化代码(一时没找到例子，或许acm大佬会知道)
* 参数传递 (论如何用C语言写一个swap函数)
* 构造高级数据结构 (如:树,链表)
* 黑科技

---

## 剩下的简单的知识点
* malloc
* free
* realloc


---

# 黑科技(怕是仍然无法满足饥渴的大佬们)

---

## 黑科技
* 访问私有变量  
若是存在一个库，你只拥有编译后的文件以及库的头文件，若是想访问其中的私有变量可以通过偏移和指针进行访问
* 执行shellcode
##
    !C
    unsigned char code *c = {巴拉巴拉一堆};
    ((void (*)())(c))();

上面将c强制转换为函数指针并执行

* 结构体中实现动态数组
##
    !C
    struct a
    {
        xxxx
        xxxx
        int a[1];
    };
    struct a *st = (struct a*)malloc(sizeof(a) + N*sizeof(int)); //这样可以一次释放

---

## 黑科技
其实还有很多的黑科技，只是做到这里的时候已经4点了，实在是修不下去了

我欲修仙，法力无边  
就先到这吧